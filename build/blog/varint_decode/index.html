<!DOCTYPE html>
<html lang="en"><head><title>VarInt Decoding is slow! üê¢ | SKye's Blog</title><link rel="stylesheet" href="/_pyro/bundle.css"/><meta name="description" content="No Description"/><meta name="viewport" content="width=device-width"/><link rel="icon" type="image/png" href="/icon.png"/><style>/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgba(0,0,0,0);--un-ring-shadow:0 0 rgba(0,0,0,0);--un-shadow-inset: ;--un-shadow:0 0 rgba(0,0,0,0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgba(0,0,0,0);--un-ring-shadow:0 0 rgba(0,0,0,0);--un-shadow-inset: ;--un-shadow:0 0 rgba(0,0,0,0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: default */
.z-10{z-index:10;}
.my{margin-top:1rem;margin-bottom:1rem;}
.ml-auto{margin-left:auto;}
.mr-4{margin-right:1rem;}
.inline{display:inline;}
.h-16{height:4rem;}
.h-8{height:2rem;}
.h-full{height:100%;}
.min-h-screen{min-height:100vh;}
.w-4{width:1rem;}
.w-8{width:2rem;}
.w-full{width:100%;}
.max-w-screen-lg{max-width:1024px;}
.flex{display:flex;}
.flex-grow{flex-grow:1;}
.flex-col{flex-direction:column;}
.flex-wrap{flex-wrap:wrap;}
.items-center{align-items:center;}
.justify-center{justify-content:center;}
.justify-around{justify-content:space-around;}
.gap-1{gap:0.25rem;}
.gap-12{gap:3rem;}
.gap-2{gap:0.5rem;}
.gap-4{gap:1rem;}
.gap-8{gap:2rem;}
.overflow-hidden{overflow:hidden;}
.whitespace-pre{white-space:pre;}
.border-t{border-top-width:1px;}
.bg-white{--un-bg-opacity:1;background-color:rgba(255,255,255,var(--un-bg-opacity));}
.px-4{padding-left:1rem;padding-right:1rem;}
.py-12{padding-top:3rem;padding-bottom:3rem;}
.py-4{padding-top:1rem;padding-bottom:1rem;}
.pb-4{padding-bottom:1rem;}
.text-5xl{font-size:3rem;line-height:1;}
.text-lg{font-size:1.125rem;line-height:1.75rem;}
.text-sm{font-size:0.875rem;line-height:1.25rem;}
.font-bold{font-weight:700;}
.font-semibold{font-weight:600;}
.text-gray-100{--un-text-opacity:1;color:rgba(243,244,246,var(--un-text-opacity));}
.text-gray-500{--un-text-opacity:1;color:rgba(107,114,128,var(--un-text-opacity));}
.text-gray-800{--un-text-opacity:1;color:rgba(31,41,55,var(--un-text-opacity));}
.hover\:text-gray-500:hover{--un-text-opacity:1;color:rgba(107,114,128,var(--un-text-opacity));}
.hover\:underline:hover{text-decoration-line:underline;}
.shadow-sm{--un-shadow:var(--un-shadow-inset) 0 1px 2px 0 var(--un-shadow-color, rgba(0,0,0,0.05));box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}
@media (prefers-color-scheme: dark){
.dark\:border-gray-700{--un-border-opacity:1;border-color:rgba(55,65,81,var(--un-border-opacity));}
.dark\:bg-black{--un-bg-opacity:1;background-color:rgba(0,0,0,var(--un-bg-opacity));}
.dark\:text-gray-100{--un-text-opacity:1;color:rgba(243,244,246,var(--un-text-opacity));}
.dark\:text-gray-200{--un-text-opacity:1;color:rgba(229,231,235,var(--un-text-opacity));}
.dark\:text-gray-400{--un-text-opacity:1;color:rgba(156,163,175,var(--un-text-opacity));}
.dark\:hover\:text-gray-400:hover{--un-text-opacity:1;color:rgba(156,163,175,var(--un-text-opacity));}
}</style></head><body class="flex flex-col min-h-screen dark:text-gray-200" style="background-color:rgb(254, 165, 125);"><header class="w-full h-16 shadow-sm flex gap-4 items-center px-4 bg-white dark:bg-black text-gray-800 dark:text-gray-200 z-10"><a href="/"><h1 class="font-semibold text-lg text-gray-800 flex items-center gap-2 dark:text-gray-200 mr-4"><image src="/icon.png" class="w-8 h-8"></image>SKye's Blog</h1></a><a class="hover:text-gray-500 dark:hover:text-gray-400" href="/blog">Blog</a><a class="hover:text-gray-500 dark:hover:text-gray-400" href="/ranting">Rants</a><div class="flex gap-4 items-center ml-auto text-gray-100"></div></header><div class="flex gap-12 flex-grow bg-white dark:bg-black justify-center"><div class="flex-grow max-w-screen-lg flex flex-col gap-8 py-4 overflow-hidden"><h1 class="text-5xl font-bold text-gray-800 dark:text-gray-100">VarInt Decoding is slow! üê¢</h1><div class="markdown-body"><h1 id="lets-make-it-48x-faster-üöÄ"><a class="anchor" aria-hidden="true" tabindex="-1" href="#lets-make-it-48x-faster-üöÄ"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Let&#39;s make it 48x faster! üöÄ</h1><p>These days LEB128 VarInts are used everywhere. From V8, WebAssembly, protobufs
and more. They&#39;re used in almost every binary format that wants to make integers
as small as possible without losing data. Almost every language has some
decoding / encoding package or module for it. Today we&#39;re going to look at the
implementation of Deno&#39;s STD library and how we can use V8 and javascript quirks
to make the algorithm 48x faster than Deno&#39;s STD library implementation</p>
<h2 id="what-is-a-varint"><a class="anchor" aria-hidden="true" tabindex="-1" href="#what-is-a-varint"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What is a VarInt</h2><p>A varint is a <b><i>var</i></b>iable <b><i>int</i></b>eger. Its size is between
1-5 bytes for a 32-bit integer or 1-10 bytes for a 64-bit integer. This variable
size means that smaller numbers can be stored more efficiently. A good usecase
for them are in things like protobufs or WebAssembly binaries, where smaller
numbers are common.</p>
<p>You may ask yourself now &quot;how do you know how big a varint is?&quot; That is done by
using 7-bits out of 8-bits of every byte as a value and reserving the last bit
(<code>0x80</code> in hex) as a flag to indicate whether the next byte should also be
decoded as part of the integer value.</p>
<h2 id="why-is-decoding-slow-in-javascript"><a class="anchor" aria-hidden="true" tabindex="-1" href="#why-is-decoding-slow-in-javascript"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why is decoding slow in JavaScript?</h2><p>It is actually not. Decoding 32-bit integers is actually quite fast in
JavaScript. This is because bitwise operations on a <code>number</code> are usually done as
machine code instructions on a 32-bit number internally [[SHOW u32 VARINT
BENCHMARK HERE]]. The problem comes from the 64-bit numbers which cannot be done
with a <code>number</code> but have to be done with a <code>BigInt</code>. <code>BigInt</code> is really handy
for when you need integers of a arbitrary precision like <code>420 ** 69</code>. But now
the problem is not with storing values bigger than 32-bits. But with the fact
that operations on a <code>BigInt</code> are really really slow.</p>
<p>This is Deno&#39;s standard library function for decoding a 64-bit varint:</p>
<pre><code class="notranslate">export const MaxUInt64 = 18446744073709551615n;
export const MaxVarIntLen64 = 10;
export const MaxVarIntLen32 = 5;

const MSB = 0x80;
const REST = 0x7f;
const SHIFT = 7;
const MSBN = 0x80n;
const SHIFTN = 7n;

export function decode(buf: Uint8Array, offset = 0): [bigint, number] {
  for (
    let i = offset,
      len = Math.min(buf.length, offset + MaxVarIntLen64),
      shift = 0,
      decoded = 0n;
    i &lt; len;
    i += 1, shift += SHIFT
  ) {
    const byte = buf[i];
    decoded += BigInt((byte &amp; REST) * Math.pow(2, shift));
    if (!(byte &amp; MSB) &amp;&amp; decoded &gt; MaxUInt64) {
      throw new RangeError(&quot;overflow varint&quot;);
    }
    if (!(byte &amp; MSB)) return [decoded, i + 1];
  }
  throw new RangeError(&quot;malformed or overflow varint&quot;);
}</code></pre><p>It&#39;s not too bad when it comes to performance. It takes about 1.4¬µs per
iteration (on my machine) but there have been faster implementations of the same
algorithm:</p>
<pre><code class="notranslate">export function bigintDecode(
  buffer: Uint8Array,
): [bigint, number] {
  let value = 0n;
  let length = 0;
  let i = 0;
  while (true) {
    const currentByte = BigInt(buffer[i]);
    value |= (currentByte &amp; 0x7Fn) &lt;&lt; BigInt(length);
    length += 7;
    i++;
    if (i &gt; 10) throw new Error(&quot;Max Length Reached&quot;);

    if ((currentByte &amp; 0x80n) !== 0x80n) break;
  }

  return [value, i];
}</code></pre><p>This algorithm is already a lot faster. It takes about 580ns (0.58¬µs) per
iteration which is more than double the performance but still nowhere near the
48x increase mentioned above</p>
<h2 id="lets-use-webassembly"><a class="anchor" aria-hidden="true" tabindex="-1" href="#lets-use-webassembly"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Let&#39;s use WebAssembly!</h2><p>After not finding a faster way of decoding varints in JavaScript I started to
think &quot;what about WebAssembly? That has 64-bit integers.&quot; And so I started
learning about WebAssembly text. It&#39;s the 1 to 1 text equivalent of a
WebAssembly binary. Kinda like how asm is that for machine code.</p>
<pre><code class="notranslate">(module
  (memory (export &quot;memory&quot;) 1)
  (func $read
    (export &quot;read&quot;)
    (param $ptr i32)
    (result i64 i32)
    (local $v i64)
    (local $length i64)
    (local $temp i64)

    (block $B0
      (loop $L0
        ;; CurrentByte
        local.get $ptr
        i64.load8_u
        local.tee $temp
        i64.const 127
        i64.and

        ;; &lt;&lt; 7 * length
        local.get $length
        i64.shl
        ;; value |= i64.shl
        local.get $v
        i64.or
        local.set $v

        ;; length++;
        local.get $length
        i64.const 7
        i64.add
        local.tee $length

        ;; CurrentByte
        local.get $temp
        i64.const 128
        i64.and
        i64.eqz
        br_if $B0

        ;; Move to next iteration
        local.get $ptr
        i32.const 1
        i32.add
        local.set $ptr

        ;; Branch if not over 70
        i64.const 70
        i64.lt_u
        br_if $L0
      )
      unreachable
    )

    local.get $v
    local.get $length
    i64.const 7
    i64.div_u
    i32.wrap_i64
  )
)</code></pre><p>This code is quite complex to understand but it&#39;s the same algorithm as the
TypeScript code in the last section. After benchmarking we can see this takes
about 168ns (0.168us) per iteration. That is already coming in quite good.
Overall a 8x performance improvement. But why is it nowhere near the 48x? This
is due to the fact that WebAssembly and JavaScript have a bit of overhead when
calling into the other language. This is because of the data we copy and pass to
WASM and because V8 (and most other engines) don&#39;t do call inlining near the
language boundary. While it can do that with JS&lt;=&gt;JS calls and WASM&lt;=&gt;WASM calls</p>
<h2 id="new-algorithm"><a class="anchor" aria-hidden="true" tabindex="-1" href="#new-algorithm"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>New &quot;Algorithm&quot;</h2><p>After a 2 weeks of summercamp and thinking for a long while I came up with a
idea. What if I use JavaScript but not a <code>BigInt</code> ü§î This might sound weird cuz
earlier I&#39;ve said that 32-bits are not enough for 64-bit numbers. But what if we
just use two 32-bit integers and then cast it to a <code>BigInt</code>. And in a hour I
created my initial implementation as seen below.</p>
<pre><code class="notranslate">export function jsDecodeV1(input: Uint8Array): bigint {
  const ab = new ArrayBuffer(8);
  const u32View = new Uint32Array(ab);
  const u64View = new BigUint64Array(ab);

  let intermediate = 0;
  let position = 0;

  for (let i = 0; i &lt; input.length; i++) {
    if (i === 11) throw new Error(&quot;Maximum size reached&quot;);

    const byte = input[i];

    // 1. Take the lower 7 bits of the byte.
    // 2. Shift the bits into the correct position.
    // 3. Bitwise OR it with the intermediate value
    // QUIRK: in the 5th (and 10th) iteration of this loop it will overflow on the shift.
    // This causes only the lower 4 bits to be shifted into place and removing the upper 3 bits
    intermediate |= (byte &amp; 0x7F) &lt;&lt; position;

    // if the intermediate value is full. Write it to the view
    // Else just add 7 to the position
    if (position === 28) {
      // Write to the view
      u32View[0] = intermediate;
      // set &#x60;intermediate&#x60; to the remaining 3 bits
      // We only want the remaining three bits because the other 4 have been &quot;consumed&quot; on line 21
      intermediate = (byte &gt;&gt;&gt; 3) &amp; 0x07;
      // set &#x60;positon&#x60; to 3 because we have written 3 bits
      position = 3;
    } else {
      position += 7;
    }

    // if no continuation bit.
    // then write the intermediate value to the empty &quot;slot&quot;
    if ((byte &amp; 0x80) !== 0x80) {
      // if the first slot is taken. Take the second slot
      u32View[Number(i &gt; 4)] = intermediate;
      break;
    }
  }

  // Cast the two u32&#x27;s to a u64 bigint
  return u64View[0];
}</code></pre><p>It fully works as expected but it&#39;s 1.5x slower than the standard library&#39;s
implementation. If bitwise operations are faster on <code>number</code> than on <code>BigInt</code>.
Then why is this algorithm slower?</p>
<h2 id="lets-dig-deeper"><a class="anchor" aria-hidden="true" tabindex="-1" href="#lets-dig-deeper"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lets Dig Deeper</h2><p>Why is our algorithm slower? After trying some things and looking at some basic
optimization I found a few things that were causing the code to be slower than
expected.</p>
<h3 id="allocations"><a class="anchor" aria-hidden="true" tabindex="-1" href="#allocations"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Allocations</h3><p>At the beginning of the code we see 3 lines of code.</p>
<pre><code class="notranslate">const ab = new ArrayBuffer(8);
const u32View = new Uint32Array(ab);
const u64View = new BigUint64Array(ab);</code></pre><p>These 3 lines allocate a small buffer that we use to cast the 2 u32&#39;s into a
<code>BigInt</code>. What if we move that allocation to the global scope. in our case, we
don&#39;t need separate buffers per call, so we can hoist the allocation.</p>
<pre><code class="notranslate">const AB = new ArrayBuffer(8);
const U32_VIEW = new Uint32Array(AB);
const U64_VIEW = new BigUint64Array(AB);

export function jsDecodeV2(input: Uint8Array): bigint {
  U64_VIEW[0] = 0n;
  let intermediate = 0;
  let position = 0;

  for (let i = 0; i &lt; input.length; i++) {
    if (i === 11) throw new Error(&quot;Maximum size reached&quot;);

    const byte = input[i];

    // 1. Take the lower 7 bits of the byte.
    // 2. Shift the bits into the correct position.
    // 3. Bitwise OR it with the intermediate value
    // QUIRK: in the 5th (and 10th) iteration of this loop it will overflow on the shift.
    // This causes only the lower 4 bits to be shifted into place and removing the upper 3 bits
    intermediate |= (byte &amp; 0x7F) &lt;&lt; position;

    // if the intermediate value is full. Write it to the view
    // Else just add 7 to the position
    if (position === 28) {
      // Write to the view
      U32_VIEW[0] = intermediate;
      // set &#x60;intermediate&#x60; to the remaining 3 bits
      // We only want the remaining three bits because the other 4 have been &quot;consumed&quot; on line 21
      intermediate = (byte &gt;&gt;&gt; 3) &amp; 0x07;
      // set &#x60;positon&#x60; to 3 because we have written 3 bits
      position = 3;
    } else {
      position += 7;
    }

    // if no continuation bit.
    // then write the intermediate value to the empty &quot;slot&quot;
    if ((byte &amp; 0x80) !== 0x80) {
      // if the first slot is taken. Take the second slot
      U32_VIEW[Number(i &gt; 4)] = intermediate;
      break;
    }
  }

  // Cast the two u32&#x27;s to a u64 bigint
  return U64_VIEW[0];
}</code></pre><p>After changing the code a little we see major performance gains. Going from 1.5x
slower than Deno&#39;s std implementation to going 35ns per iterations! We&#39;re
already nearly there in terms of performance. But what else can we do?</p>
<h3 id="property-access"><a class="anchor" aria-hidden="true" tabindex="-1" href="#property-access"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Property Access</h3><p>Another bit of optimizations comes from property access. The whole time we were
accessing the array&#39;s <code>.length</code> property. Which in theory won&#39;t change for us
because we are not mutating the array. Sadly enough the compiler cannot
guarantee that that is not the case so each time it will access the property and
check it&#39;s value. A simple <code>const length = input.length</code> just before the loop
let&#39;s the compiler access the property once and then guarantee that it won&#39;t
need to loop more than <code>length</code> even if <code>input</code> is mutated. This small
optimization also gives us another 3.8ns per iteration. Getting us to 31ns per
iteration</p>
<pre><code class="notranslate">const AB = new ArrayBuffer(8);
const U32_VIEW = new Uint32Array(AB);
const U64_VIEW = new BigUint64Array(AB);

export function jsDecodeV3(input: Uint8Array): bigint {
  U64_VIEW[0] = 0n;
  let intermediate = 0;
  let position = 0;
  const length = input.length;

  for (let i = 0; i &lt; length; i++) {
    if (i === 11) throw new Error(&quot;Maximum size reached&quot;);

    const byte = input[i];

    // 1. Take the lower 7 bits of the byte.
    // 2. Shift the bits into the correct position.
    // 3. Bitwise OR it with the intermediate value
    // QUIRK: in the 5th (and 10th) iteration of this loop it will overflow on the shift.
    // This causes only the lower 4 bits to be shifted into place and removing the upper 3 bits

    intermediate |= (byte &amp; 0x7F) &lt;&lt; position;

    // if the intermediate value is full. Write it to the view
    // Else just add 7 to the position
    if (position === 28) {
      // Write to the view
      U32_VIEW[0] = intermediate;
      // set &#x60;intermediate&#x60; to the remaining 3 bits
      // We only want the remaining three bits because the other 4 have been &quot;consumed&quot; on line 21
      intermediate = (byte &gt;&gt;&gt; 3) &amp; 0x07;
      // set &#x60;positon&#x60; to 3 because we have written 3 bits
      position = 3;
    } else {
      position += 7;
    }

    // if no continuation bit.
    // then write the intermediate value to the empty &quot;slot&quot;
    if ((byte &amp; 0x80) !== 0x80) {
      // if the first slot is taken. Take the second slot
      U32_VIEW[Number(i &gt; 4)] = intermediate;
      break;
    }
  }

  // Cast the two u32&#x27;s to a u64 bigint
  return U64_VIEW[0];
}</code></pre><h3 id="branch-elimination"><a class="anchor" aria-hidden="true" tabindex="-1" href="#branch-elimination"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Branch elimination</h3><p>Currently we got a nasty <code>if else</code> in our code. The <code>if</code> branch if really
important. But is there anything we can do about the <code>else</code>? YES! We can do
something about it. What if we change it so that we unconditionally add 7 to
<code>position</code>.</p>
<pre><code class="notranslate">const AB = new ArrayBuffer(8);
const U32_VIEW = new Uint32Array(AB);
const U64_VIEW = new BigUint64Array(AB);

export function jsDecodeV4(input: Uint8Array): bigint {
  U64_VIEW[0] = 0n;
  let intermediate = 0;
  let position = 0;
  const length = input.length;

  for (let i = 0; i &lt; length; i++) {
    if (i === 11) throw new Error(&quot;Maximum size reached&quot;);

    const byte = input[i];

    // 1. Take the lower 7 bits of the byte.
    // 2. Shift the bits into the correct position.
    // 3. Bitwise OR it with the intermediate value
    // QUIRK: in the 5th (and 10th) iteration of this loop it will overflow on the shift.
    // This causes only the lower 4 bits to be shifted into place and removing the upper 3 bits
    intermediate |= (byte &amp; 0x7F) &lt;&lt; position;

    // If the intermediate value is full. Write it to the view
    if (position === 28) {
      // Write to the view
      U32_VIEW[0] = intermediate;
      // set &#x60;intermediate&#x60; to the remaining 3 bits
      // We only want the remaining three bits because the other 4 have been &quot;consumed&quot; on line 21
      intermediate = (byte &gt;&gt;&gt; 3) &amp; 0x07;
      // set &#x60;position&#x60; to -4 because later 7 will be added, making it 3
      position = -4;
    }

    position += 7;

    // if no continuation bit.
    // then write the intermediate value to the empty &quot;slot&quot;
    if ((byte &amp; 0x80) !== 0x80) {
      // if the first slot is taken. Take the second slot
      U32_VIEW[Number(i &gt; 4)] = intermediate;
      break;
    }
  }

  // Cast the two u32&#x27;s to a u64 bigint
  return U64_VIEW[0];
}</code></pre><p>We eliminated one more branch call which saved us another 2 ns per iteration.
Which get&#39;s us from 31ns down to 28ns.</p>
<h2 id="summary"><a class="anchor" aria-hidden="true" tabindex="-1" href="#summary"><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Summary</h2><p>In conclusion it&#39;s possible to make this decoding algoritm super fast in
javascript. This it did require a lot of specific knowledge about V8, Writing
code that a JIT compiler can easily optimize and figuring out the most efficient
way of using your given constraints and resources.</p>
</div></div></div><footer class="px-4 py-12 w-full flex justify-center text-gray-800 dark:text-gray-200 border-t dark:border-gray-700 bg-white dark:bg-black"><div class="max-w-screen-lg w-full flex flex-wrap justify-around"><image src="/icon.png" class="w-8 h-8"></image><div><p class="font-bold pb-4">Quick Navigation</p><ul class="flex flex-col gap-2"><li><a class="flex items-center gap-1 hover:underline" href="/">Main</a></li><li><a class="flex items-center gap-1 hover:underline" href="/blog">Blog</a></li><li><a class="flex items-center gap-1 hover:underline" href="/ranting">Rants</a></li></ul></div><div><p class="font-bold pb-4">Other Sites</p><ul class="flex flex-col gap-2"><li><a class="flex items-center gap-1 hover:underline" href="https://github.com/mierenmanz">Github<svg xmlns="http://www.w3.org/2000/svg" class="inline w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M11 7h-5a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-5"></path><path d="M10 14l10 -10"></path><path d="M15 4l5 0l0 5"></path></svg></a></li><li><a class="flex items-center gap-1 hover:underline" href="https://github.com/sponsors/MierenManz">Support Me<svg xmlns="http://www.w3.org/2000/svg" class="inline w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M11 7h-5a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-5"></path><path d="M10 14l10 -10"></path><path d="M15 4l5 0l0 5"></path></svg></a></li></ul></div><div class="h-full flex flex-col justify-around"><p class="whitespace-pre text-gray-500 dark:text-gray-400 text-sm">Copyright ¬© 2023 Skye</p><div></div></div></div></footer></body></html>